<?php
/**
 * BudgetingApi
 * PHP version 7.4
 *
 * @category Class
 * @package  OpenAPI\Client
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */

/**
 * PocketSmith
 *
 * The PocketSmith API
 *
 * The version of the OpenAPI document: 2.0
 * Contact: api@pocketsmith.com
 * Generated by: https://openapi-generator.tech
 * OpenAPI Generator version: 6.6.0
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace OpenAPI\Client\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\ConnectException;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use OpenAPI\Client\ApiException;
use OpenAPI\Client\Configuration;
use OpenAPI\Client\HeaderSelector;
use OpenAPI\Client\ObjectSerializer;

/**
 * BudgetingApi Class Doc Comment
 *
 * @category Class
 * @package  OpenAPI\Client
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */
class BudgetingApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @var int Host index
     */
    protected $hostIndex;

    /** @var string[] $contentTypes **/
    public const contentTypes = [
        'usersIdBudgetGet' => [
            'application/json',
        ],
        'usersIdBudgetSummaryGet' => [
            'application/json',
        ],
        'usersIdForecastCacheDelete' => [
            'application/json',
        ],
        'usersIdTrendAnalysisGet' => [
            'application/json',
        ],
    ];

/**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     * @param int             $hostIndex (Optional) host index to select the list of hosts if defined in the OpenAPI spec
     */
    public function __construct(
        ClientInterface $client = null,
        Configuration $config = null,
        HeaderSelector $selector = null,
        $hostIndex = 0
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: new Configuration();
        $this->headerSelector = $selector ?: new HeaderSelector();
        $this->hostIndex = $hostIndex;
    }

    /**
     * Set the host index
     *
     * @param int $hostIndex Host index (required)
     */
    public function setHostIndex($hostIndex): void
    {
        $this->hostIndex = $hostIndex;
    }

    /**
     * Get the host index
     *
     * @return int Host index
     */
    public function getHostIndex()
    {
        return $this->hostIndex;
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation usersIdBudgetGet
     *
     * List budget for user
     *
     * @param  int $id The unique identifier of the account. (required)
     * @param  bool $roll_up Whether parent categories should have their children rolled up into them. When used, the children will still appear in the collection on their own, but their actual and forecast figures will be rolled up to the root parent. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['usersIdBudgetGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\BudgetAnalysisPackage[]
     */
    public function usersIdBudgetGet($id, $roll_up = null, string $contentType = self::contentTypes['usersIdBudgetGet'][0])
    {
        list($response) = $this->usersIdBudgetGetWithHttpInfo($id, $roll_up, $contentType);
        return $response;
    }

    /**
     * Operation usersIdBudgetGetWithHttpInfo
     *
     * List budget for user
     *
     * @param  int $id The unique identifier of the account. (required)
     * @param  bool $roll_up Whether parent categories should have their children rolled up into them. When used, the children will still appear in the collection on their own, but their actual and forecast figures will be rolled up to the root parent. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['usersIdBudgetGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\BudgetAnalysisPackage[], HTTP status code, HTTP response headers (array of strings)
     */
    public function usersIdBudgetGetWithHttpInfo($id, $roll_up = null, string $contentType = self::contentTypes['usersIdBudgetGet'][0])
    {
        $request = $this->usersIdBudgetGetRequest($id, $roll_up, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\BudgetAnalysisPackage[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\BudgetAnalysisPackage[]' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\BudgetAnalysisPackage[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\BudgetAnalysisPackage[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\BudgetAnalysisPackage[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation usersIdBudgetGetAsync
     *
     * List budget for user
     *
     * @param  int $id The unique identifier of the account. (required)
     * @param  bool $roll_up Whether parent categories should have their children rolled up into them. When used, the children will still appear in the collection on their own, but their actual and forecast figures will be rolled up to the root parent. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['usersIdBudgetGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function usersIdBudgetGetAsync($id, $roll_up = null, string $contentType = self::contentTypes['usersIdBudgetGet'][0])
    {
        return $this->usersIdBudgetGetAsyncWithHttpInfo($id, $roll_up, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation usersIdBudgetGetAsyncWithHttpInfo
     *
     * List budget for user
     *
     * @param  int $id The unique identifier of the account. (required)
     * @param  bool $roll_up Whether parent categories should have their children rolled up into them. When used, the children will still appear in the collection on their own, but their actual and forecast figures will be rolled up to the root parent. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['usersIdBudgetGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function usersIdBudgetGetAsyncWithHttpInfo($id, $roll_up = null, string $contentType = self::contentTypes['usersIdBudgetGet'][0])
    {
        $returnType = '\OpenAPI\Client\Model\BudgetAnalysisPackage[]';
        $request = $this->usersIdBudgetGetRequest($id, $roll_up, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'usersIdBudgetGet'
     *
     * @param  int $id The unique identifier of the account. (required)
     * @param  bool $roll_up Whether parent categories should have their children rolled up into them. When used, the children will still appear in the collection on their own, but their actual and forecast figures will be rolled up to the root parent. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['usersIdBudgetGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function usersIdBudgetGetRequest($id, $roll_up = null, string $contentType = self::contentTypes['usersIdBudgetGet'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling usersIdBudgetGet'
            );
        }



        $resourcePath = '/users/{id}/budget';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $roll_up,
            'roll_up', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Developer-Key');
        if ($apiKey !== null) {
            $headers['X-Developer-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation usersIdBudgetSummaryGet
     *
     * Get budget summary for user
     *
     * @param  int $id The unique identifier of the user. (required)
     * @param  string $period The period to analyse in, one of &#x60;weeks&#x60;, &#x60;months&#x60; or &#x60;years&#x60;. Also supported is &#x60;event&#x60;, although event period analysis is only possible when the budget events gathered align, so in this case where all categories are analysed together, it&#39;s highly unlikely that event period analysis will be possible. (required)
     * @param  int $interval The period interval, e.g. if the interval is 2 and the period is weeks, the budget will be analysed fortnightly. (required)
     * @param  string $start_date The date to start analysing the budget from. This will be bumped out to make full periods as necessary. (required)
     * @param  string $end_date The date to stop analysing the budget from. This will be bumped out to make full periods as necessary. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['usersIdBudgetSummaryGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\BudgetAnalysisPackage[]|\OpenAPI\Client\Model\Error|\OpenAPI\Client\Model\Error|\OpenAPI\Client\Model\Error
     */
    public function usersIdBudgetSummaryGet($id, $period, $interval, $start_date, $end_date, string $contentType = self::contentTypes['usersIdBudgetSummaryGet'][0])
    {
        list($response) = $this->usersIdBudgetSummaryGetWithHttpInfo($id, $period, $interval, $start_date, $end_date, $contentType);
        return $response;
    }

    /**
     * Operation usersIdBudgetSummaryGetWithHttpInfo
     *
     * Get budget summary for user
     *
     * @param  int $id The unique identifier of the user. (required)
     * @param  string $period The period to analyse in, one of &#x60;weeks&#x60;, &#x60;months&#x60; or &#x60;years&#x60;. Also supported is &#x60;event&#x60;, although event period analysis is only possible when the budget events gathered align, so in this case where all categories are analysed together, it&#39;s highly unlikely that event period analysis will be possible. (required)
     * @param  int $interval The period interval, e.g. if the interval is 2 and the period is weeks, the budget will be analysed fortnightly. (required)
     * @param  string $start_date The date to start analysing the budget from. This will be bumped out to make full periods as necessary. (required)
     * @param  string $end_date The date to stop analysing the budget from. This will be bumped out to make full periods as necessary. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['usersIdBudgetSummaryGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\BudgetAnalysisPackage[]|\OpenAPI\Client\Model\Error|\OpenAPI\Client\Model\Error|\OpenAPI\Client\Model\Error, HTTP status code, HTTP response headers (array of strings)
     */
    public function usersIdBudgetSummaryGetWithHttpInfo($id, $period, $interval, $start_date, $end_date, string $contentType = self::contentTypes['usersIdBudgetSummaryGet'][0])
    {
        $request = $this->usersIdBudgetSummaryGetRequest($id, $period, $interval, $start_date, $end_date, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\BudgetAnalysisPackage[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\BudgetAnalysisPackage[]' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\BudgetAnalysisPackage[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('\OpenAPI\Client\Model\Error' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\Error' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\Error', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 403:
                    if ('\OpenAPI\Client\Model\Error' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\Error' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\Error', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 404:
                    if ('\OpenAPI\Client\Model\Error' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\Error' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\Error', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\BudgetAnalysisPackage[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\BudgetAnalysisPackage[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation usersIdBudgetSummaryGetAsync
     *
     * Get budget summary for user
     *
     * @param  int $id The unique identifier of the user. (required)
     * @param  string $period The period to analyse in, one of &#x60;weeks&#x60;, &#x60;months&#x60; or &#x60;years&#x60;. Also supported is &#x60;event&#x60;, although event period analysis is only possible when the budget events gathered align, so in this case where all categories are analysed together, it&#39;s highly unlikely that event period analysis will be possible. (required)
     * @param  int $interval The period interval, e.g. if the interval is 2 and the period is weeks, the budget will be analysed fortnightly. (required)
     * @param  string $start_date The date to start analysing the budget from. This will be bumped out to make full periods as necessary. (required)
     * @param  string $end_date The date to stop analysing the budget from. This will be bumped out to make full periods as necessary. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['usersIdBudgetSummaryGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function usersIdBudgetSummaryGetAsync($id, $period, $interval, $start_date, $end_date, string $contentType = self::contentTypes['usersIdBudgetSummaryGet'][0])
    {
        return $this->usersIdBudgetSummaryGetAsyncWithHttpInfo($id, $period, $interval, $start_date, $end_date, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation usersIdBudgetSummaryGetAsyncWithHttpInfo
     *
     * Get budget summary for user
     *
     * @param  int $id The unique identifier of the user. (required)
     * @param  string $period The period to analyse in, one of &#x60;weeks&#x60;, &#x60;months&#x60; or &#x60;years&#x60;. Also supported is &#x60;event&#x60;, although event period analysis is only possible when the budget events gathered align, so in this case where all categories are analysed together, it&#39;s highly unlikely that event period analysis will be possible. (required)
     * @param  int $interval The period interval, e.g. if the interval is 2 and the period is weeks, the budget will be analysed fortnightly. (required)
     * @param  string $start_date The date to start analysing the budget from. This will be bumped out to make full periods as necessary. (required)
     * @param  string $end_date The date to stop analysing the budget from. This will be bumped out to make full periods as necessary. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['usersIdBudgetSummaryGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function usersIdBudgetSummaryGetAsyncWithHttpInfo($id, $period, $interval, $start_date, $end_date, string $contentType = self::contentTypes['usersIdBudgetSummaryGet'][0])
    {
        $returnType = '\OpenAPI\Client\Model\BudgetAnalysisPackage[]';
        $request = $this->usersIdBudgetSummaryGetRequest($id, $period, $interval, $start_date, $end_date, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'usersIdBudgetSummaryGet'
     *
     * @param  int $id The unique identifier of the user. (required)
     * @param  string $period The period to analyse in, one of &#x60;weeks&#x60;, &#x60;months&#x60; or &#x60;years&#x60;. Also supported is &#x60;event&#x60;, although event period analysis is only possible when the budget events gathered align, so in this case where all categories are analysed together, it&#39;s highly unlikely that event period analysis will be possible. (required)
     * @param  int $interval The period interval, e.g. if the interval is 2 and the period is weeks, the budget will be analysed fortnightly. (required)
     * @param  string $start_date The date to start analysing the budget from. This will be bumped out to make full periods as necessary. (required)
     * @param  string $end_date The date to stop analysing the budget from. This will be bumped out to make full periods as necessary. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['usersIdBudgetSummaryGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function usersIdBudgetSummaryGetRequest($id, $period, $interval, $start_date, $end_date, string $contentType = self::contentTypes['usersIdBudgetSummaryGet'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling usersIdBudgetSummaryGet'
            );
        }

        // verify the required parameter 'period' is set
        if ($period === null || (is_array($period) && count($period) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $period when calling usersIdBudgetSummaryGet'
            );
        }

        // verify the required parameter 'interval' is set
        if ($interval === null || (is_array($interval) && count($interval) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $interval when calling usersIdBudgetSummaryGet'
            );
        }

        // verify the required parameter 'start_date' is set
        if ($start_date === null || (is_array($start_date) && count($start_date) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $start_date when calling usersIdBudgetSummaryGet'
            );
        }

        // verify the required parameter 'end_date' is set
        if ($end_date === null || (is_array($end_date) && count($end_date) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $end_date when calling usersIdBudgetSummaryGet'
            );
        }


        $resourcePath = '/users/{id}/budget_summary';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $period,
            'period', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $interval,
            'interval', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $start_date,
            'start_date', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $end_date,
            'end_date', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Developer-Key');
        if ($apiKey !== null) {
            $headers['X-Developer-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation usersIdForecastCacheDelete
     *
     * Delete forecast cache for user
     *
     * @param  int $id The unique identifier of the user. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['usersIdForecastCacheDelete'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function usersIdForecastCacheDelete($id, string $contentType = self::contentTypes['usersIdForecastCacheDelete'][0])
    {
        $this->usersIdForecastCacheDeleteWithHttpInfo($id, $contentType);
    }

    /**
     * Operation usersIdForecastCacheDeleteWithHttpInfo
     *
     * Delete forecast cache for user
     *
     * @param  int $id The unique identifier of the user. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['usersIdForecastCacheDelete'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function usersIdForecastCacheDeleteWithHttpInfo($id, string $contentType = self::contentTypes['usersIdForecastCacheDelete'][0])
    {
        $request = $this->usersIdForecastCacheDeleteRequest($id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation usersIdForecastCacheDeleteAsync
     *
     * Delete forecast cache for user
     *
     * @param  int $id The unique identifier of the user. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['usersIdForecastCacheDelete'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function usersIdForecastCacheDeleteAsync($id, string $contentType = self::contentTypes['usersIdForecastCacheDelete'][0])
    {
        return $this->usersIdForecastCacheDeleteAsyncWithHttpInfo($id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation usersIdForecastCacheDeleteAsyncWithHttpInfo
     *
     * Delete forecast cache for user
     *
     * @param  int $id The unique identifier of the user. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['usersIdForecastCacheDelete'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function usersIdForecastCacheDeleteAsyncWithHttpInfo($id, string $contentType = self::contentTypes['usersIdForecastCacheDelete'][0])
    {
        $returnType = '';
        $request = $this->usersIdForecastCacheDeleteRequest($id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'usersIdForecastCacheDelete'
     *
     * @param  int $id The unique identifier of the user. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['usersIdForecastCacheDelete'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function usersIdForecastCacheDeleteRequest($id, string $contentType = self::contentTypes['usersIdForecastCacheDelete'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling usersIdForecastCacheDelete'
            );
        }


        $resourcePath = '/users/{id}/forecast_cache';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Developer-Key');
        if ($apiKey !== null) {
            $headers['X-Developer-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation usersIdTrendAnalysisGet
     *
     * Get trend analysis for user
     *
     * @param  int $id The unique identifier of the user. (required)
     * @param  string $period The period to analyse in, one of &#x60;weeks&#x60;, &#x60;months&#x60; or &#x60;years&#x60;. Also supported is &#x60;event&#x60;, although event period analysis is only possible when the budget events gathered align, so in this case where all categories are analysed together, it&#39;s highly unlikely that event period analysis will be possible. (required)
     * @param  int $interval The period interval, e.g. if the interval is 2 and the period is weeks, the budget will be analysed fortnightly. (required)
     * @param  string $start_date The date to start analysing the budget from. This will be bumped out to make full periods as necessary. (required)
     * @param  string $end_date The date to stop analysing the budget from. This will be bumped out to make full periods as necessary. (required)
     * @param  string $categories A comma-separated list of category IDs to analyse. (required)
     * @param  string $scenarios A comma-separated list of scenario IDs to analyse. You&#39;re likely going to want to include all a user&#39;s scenarios here, unless you have reason to only analyse for a subset of scenarios. Regardless of what scenarios are analysed, all actuals (transactions) across all accounts will be included. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['usersIdTrendAnalysisGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\BudgetAnalysisPackage[]|\OpenAPI\Client\Model\Error|\OpenAPI\Client\Model\Error|\OpenAPI\Client\Model\Error|\OpenAPI\Client\Model\Error
     */
    public function usersIdTrendAnalysisGet($id, $period, $interval, $start_date, $end_date, $categories, $scenarios, string $contentType = self::contentTypes['usersIdTrendAnalysisGet'][0])
    {
        list($response) = $this->usersIdTrendAnalysisGetWithHttpInfo($id, $period, $interval, $start_date, $end_date, $categories, $scenarios, $contentType);
        return $response;
    }

    /**
     * Operation usersIdTrendAnalysisGetWithHttpInfo
     *
     * Get trend analysis for user
     *
     * @param  int $id The unique identifier of the user. (required)
     * @param  string $period The period to analyse in, one of &#x60;weeks&#x60;, &#x60;months&#x60; or &#x60;years&#x60;. Also supported is &#x60;event&#x60;, although event period analysis is only possible when the budget events gathered align, so in this case where all categories are analysed together, it&#39;s highly unlikely that event period analysis will be possible. (required)
     * @param  int $interval The period interval, e.g. if the interval is 2 and the period is weeks, the budget will be analysed fortnightly. (required)
     * @param  string $start_date The date to start analysing the budget from. This will be bumped out to make full periods as necessary. (required)
     * @param  string $end_date The date to stop analysing the budget from. This will be bumped out to make full periods as necessary. (required)
     * @param  string $categories A comma-separated list of category IDs to analyse. (required)
     * @param  string $scenarios A comma-separated list of scenario IDs to analyse. You&#39;re likely going to want to include all a user&#39;s scenarios here, unless you have reason to only analyse for a subset of scenarios. Regardless of what scenarios are analysed, all actuals (transactions) across all accounts will be included. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['usersIdTrendAnalysisGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\BudgetAnalysisPackage[]|\OpenAPI\Client\Model\Error|\OpenAPI\Client\Model\Error|\OpenAPI\Client\Model\Error|\OpenAPI\Client\Model\Error, HTTP status code, HTTP response headers (array of strings)
     */
    public function usersIdTrendAnalysisGetWithHttpInfo($id, $period, $interval, $start_date, $end_date, $categories, $scenarios, string $contentType = self::contentTypes['usersIdTrendAnalysisGet'][0])
    {
        $request = $this->usersIdTrendAnalysisGetRequest($id, $period, $interval, $start_date, $end_date, $categories, $scenarios, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\BudgetAnalysisPackage[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\BudgetAnalysisPackage[]' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\BudgetAnalysisPackage[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('\OpenAPI\Client\Model\Error' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\Error' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\Error', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 403:
                    if ('\OpenAPI\Client\Model\Error' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\Error' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\Error', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 404:
                    if ('\OpenAPI\Client\Model\Error' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\Error' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\Error', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 422:
                    if ('\OpenAPI\Client\Model\Error' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\Error' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\Error', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\BudgetAnalysisPackage[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\BudgetAnalysisPackage[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 422:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation usersIdTrendAnalysisGetAsync
     *
     * Get trend analysis for user
     *
     * @param  int $id The unique identifier of the user. (required)
     * @param  string $period The period to analyse in, one of &#x60;weeks&#x60;, &#x60;months&#x60; or &#x60;years&#x60;. Also supported is &#x60;event&#x60;, although event period analysis is only possible when the budget events gathered align, so in this case where all categories are analysed together, it&#39;s highly unlikely that event period analysis will be possible. (required)
     * @param  int $interval The period interval, e.g. if the interval is 2 and the period is weeks, the budget will be analysed fortnightly. (required)
     * @param  string $start_date The date to start analysing the budget from. This will be bumped out to make full periods as necessary. (required)
     * @param  string $end_date The date to stop analysing the budget from. This will be bumped out to make full periods as necessary. (required)
     * @param  string $categories A comma-separated list of category IDs to analyse. (required)
     * @param  string $scenarios A comma-separated list of scenario IDs to analyse. You&#39;re likely going to want to include all a user&#39;s scenarios here, unless you have reason to only analyse for a subset of scenarios. Regardless of what scenarios are analysed, all actuals (transactions) across all accounts will be included. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['usersIdTrendAnalysisGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function usersIdTrendAnalysisGetAsync($id, $period, $interval, $start_date, $end_date, $categories, $scenarios, string $contentType = self::contentTypes['usersIdTrendAnalysisGet'][0])
    {
        return $this->usersIdTrendAnalysisGetAsyncWithHttpInfo($id, $period, $interval, $start_date, $end_date, $categories, $scenarios, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation usersIdTrendAnalysisGetAsyncWithHttpInfo
     *
     * Get trend analysis for user
     *
     * @param  int $id The unique identifier of the user. (required)
     * @param  string $period The period to analyse in, one of &#x60;weeks&#x60;, &#x60;months&#x60; or &#x60;years&#x60;. Also supported is &#x60;event&#x60;, although event period analysis is only possible when the budget events gathered align, so in this case where all categories are analysed together, it&#39;s highly unlikely that event period analysis will be possible. (required)
     * @param  int $interval The period interval, e.g. if the interval is 2 and the period is weeks, the budget will be analysed fortnightly. (required)
     * @param  string $start_date The date to start analysing the budget from. This will be bumped out to make full periods as necessary. (required)
     * @param  string $end_date The date to stop analysing the budget from. This will be bumped out to make full periods as necessary. (required)
     * @param  string $categories A comma-separated list of category IDs to analyse. (required)
     * @param  string $scenarios A comma-separated list of scenario IDs to analyse. You&#39;re likely going to want to include all a user&#39;s scenarios here, unless you have reason to only analyse for a subset of scenarios. Regardless of what scenarios are analysed, all actuals (transactions) across all accounts will be included. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['usersIdTrendAnalysisGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function usersIdTrendAnalysisGetAsyncWithHttpInfo($id, $period, $interval, $start_date, $end_date, $categories, $scenarios, string $contentType = self::contentTypes['usersIdTrendAnalysisGet'][0])
    {
        $returnType = '\OpenAPI\Client\Model\BudgetAnalysisPackage[]';
        $request = $this->usersIdTrendAnalysisGetRequest($id, $period, $interval, $start_date, $end_date, $categories, $scenarios, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'usersIdTrendAnalysisGet'
     *
     * @param  int $id The unique identifier of the user. (required)
     * @param  string $period The period to analyse in, one of &#x60;weeks&#x60;, &#x60;months&#x60; or &#x60;years&#x60;. Also supported is &#x60;event&#x60;, although event period analysis is only possible when the budget events gathered align, so in this case where all categories are analysed together, it&#39;s highly unlikely that event period analysis will be possible. (required)
     * @param  int $interval The period interval, e.g. if the interval is 2 and the period is weeks, the budget will be analysed fortnightly. (required)
     * @param  string $start_date The date to start analysing the budget from. This will be bumped out to make full periods as necessary. (required)
     * @param  string $end_date The date to stop analysing the budget from. This will be bumped out to make full periods as necessary. (required)
     * @param  string $categories A comma-separated list of category IDs to analyse. (required)
     * @param  string $scenarios A comma-separated list of scenario IDs to analyse. You&#39;re likely going to want to include all a user&#39;s scenarios here, unless you have reason to only analyse for a subset of scenarios. Regardless of what scenarios are analysed, all actuals (transactions) across all accounts will be included. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['usersIdTrendAnalysisGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function usersIdTrendAnalysisGetRequest($id, $period, $interval, $start_date, $end_date, $categories, $scenarios, string $contentType = self::contentTypes['usersIdTrendAnalysisGet'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling usersIdTrendAnalysisGet'
            );
        }

        // verify the required parameter 'period' is set
        if ($period === null || (is_array($period) && count($period) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $period when calling usersIdTrendAnalysisGet'
            );
        }

        // verify the required parameter 'interval' is set
        if ($interval === null || (is_array($interval) && count($interval) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $interval when calling usersIdTrendAnalysisGet'
            );
        }

        // verify the required parameter 'start_date' is set
        if ($start_date === null || (is_array($start_date) && count($start_date) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $start_date when calling usersIdTrendAnalysisGet'
            );
        }

        // verify the required parameter 'end_date' is set
        if ($end_date === null || (is_array($end_date) && count($end_date) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $end_date when calling usersIdTrendAnalysisGet'
            );
        }

        // verify the required parameter 'categories' is set
        if ($categories === null || (is_array($categories) && count($categories) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $categories when calling usersIdTrendAnalysisGet'
            );
        }

        // verify the required parameter 'scenarios' is set
        if ($scenarios === null || (is_array($scenarios) && count($scenarios) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $scenarios when calling usersIdTrendAnalysisGet'
            );
        }


        $resourcePath = '/users/{id}/trend_analysis';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $period,
            'period', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $interval,
            'interval', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $start_date,
            'start_date', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $end_date,
            'end_date', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $categories,
            'categories', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $scenarios,
            'scenarios', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Developer-Key');
        if ($apiKey !== null) {
            $headers['X-Developer-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
